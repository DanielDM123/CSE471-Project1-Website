<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
    <link rel="stylesheet" href="style.css">
    
    <title>Document</title>
</head>
<body>
    <header>
        <h1><u>Project 1 - Effects Component</u></h1>
    </header>

    <nav>
        <a href="index.html">Homepage</a> |
        <a href="subtractive-synthesizer.html">Subtractive Synthesizer</a>
    </nav>

    <artcle>
        <h3>Here is how <u>Daniel Mar</u> implemented the Effects Component</h3>
        <!-- Add report here -->

        <h4>Grading Elements:</h4>
        <ol>
            <li>Compentent Passess Audio</li>    
            <li>4 Effects</li>
            <li>Controllable Effects Send</li>
        </ol>

        <hr>

        <!-- Compoent Passes Audio -->
        <h3 class="centerText"><u>Compoent Passes Audio</u></h3>
        <p>The main way I passed in audio was in the CSynthesizer::Generate() function. Before that, the first thing I did was initialize each of the effect objects in CSynthesizer's header file. Then, during phase 1, of Generate() funciton when we are configuring the instruments, I would assign each instrument their effect that it read from the score file. Afterwards during phase 3, shortly after calling instrument->Generate(), I have a set of if statements that would check the effect value for the instrument, and apply that effect. 
        </p>

        <hr>

        <h3 class="centerText"><u>4 Effects</u></h3>

        <!-- Reverb Effect -->
         <h4>Reverberation Effect:</h4>
         <p>I implemented this very similarly to the transform equations from step 4. First, I had created a circular queue in the CReverberation class. I also created a Process() function with parameters double* frameIn and double* frameOut. frameIn is the input frame that holds the unmodified frequency, and likewise, frameOut is the output frame where the function will store the modified frequency.  
        </p>
        <p>
        Afterwards in the Process() function, I would first update the read location pointer. The main transform equation I used was “y = x + 0.4 * y(t-4410)”. It would first read from the INPUT queue. Then it would multiply the queue output with a weight of 0.4, and add that with the input frame. Finally, I would store the <b>OUTPUT</b> frame into the queue and move the write location pointer.  
        </p>

        <!-- Flanging Effect -->
         <h4>Flanging Effect:</h4>
         <p>This is implemented just like reverberation class mentioned above and the transfer equations from step 4. I also created a circular queue in CFlanging, and had a Process() function. The first thing the Process() function would do is update the read location pointer. The main transfer equation was the exact same, “y = x + 0.4 * y(t-4410)”, so it was the same process as above. The main difference was that I would store the <b>INPUT</b> frame into the circular queue instead of the output frame.</p>

        <!-- Compression Effect -->
         <h4>Compression Effect:</h4>
         <p>The basic implementation is just like the other effects above, where there is a CCompression class, and within that class is a Process() function with the same parameters. The Process() function checks if the input frame has a frequency that is higher than the threshold. If it was, it would calculate a new gain by first finding the percentage of thresholdN by the input frame. Then put that percentage by the power of the ratio to find the new gain. If the frequency was below the threshold, the gain would be set to 1. The output would be created by multiplying the input frame by the gain. 
</p>

        <!-- Noise Gate Effect -->
         <h4>Noise Gate Effect:</h4>
         <p>This effect was implemented just like the compression effect. Similarly, there is a CNoiseGate class with a Process() function. It would also have an if statement, but it would instead check if the input frame is below a certain threshold. If it was, it would just set the gain to 0, and 1 if not. The output is created the same way, where the input frame is multiplied by the gain.   
</p>

        <hr>

        <h3 class="centerText"><u>Controllable Effects Send</u></h3>
        <p>The main way I made my effects series is by having multiple if statements in a row during phase 3a in the Synthesizer::Generate() function, and storing multiple effects in one effect tag. When reading from the score file, the instrument will store the multiple effects by splitting up the string by the comma, and then put it into a vector. During phase 3a in Generate(), it will loop through each effect the instrument has and apply that effect in this order: reverberation, noise gate, compression, and flanging. So, if an instrument has the effects compression and reverberation, reverberation will be applied first, then compression afterwards. </p>


        
    </artcle>
    


</body>
</html>